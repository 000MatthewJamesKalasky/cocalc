"""
Miscellaneous functions.
"""

import os, tempfile
from StringIO import StringIO

import requests

# this exception is used by client code
ConnectionError = requests.ConnectionError

def get(url, data=None, timeout=1):
    """
    GET the url with optional parameters as specified by the data
    variable.

    INPUT:
    
    - ``url`` -- string
    - ``data`` -- dict or None (defaults to empty dict); GET vars
    - ``timeout`` -- (default: 1) time in seconds to attempt to
      complete the GET before raising the ConnectionError exception.

    OUTPUT:

    - string

    EXAMPLES::

    We test the timeout option::
    
        >>> get('http://cnn.com',timeout=1e-3)
        Traceback (most recent call last):
        ...
        Timeout: Request timed out.

    We pass data to a server, which happens to respond with some text
    in JSON format::
    
        >>> import subprocess_server; r = subprocess_server.Daemon(5000)
        >>> s = get('http://localhost:5000/popen', data={'command':'python'})
        >>> print s
        {
          "status": "ok", 
          "pid": ..., 
          "execpath": "...tmp..."
        }
    """
    if data is None: data = {}
    return requests.get(url, params=data, timeout=timeout).text

def post(url, data=None, files=None, timeout=10):
    """
    POST the dictionary of data to the url, and return the response
    from the server.

    INPUT:

    - ``url`` -- string
    - ``data`` -- dict or None (defaults to empty dict); POST vars
    - ``files`` -- dict or None (defaults to empty dict); keys are
      file names and values are the contents
    - ``timeout`` -- (default: 10) time in seconds to attempt to
      complete the POST before raising the ConnectionError exception.

    OUTPUT:

    - string

    EXAMPLES::

        >>> import frontend; R = frontend.Daemon(5000)
        >>> from misc import post, get
        >>> a = get('http://localhost:5000/killall')  # for doctesting
        >>> a = get('http://localhost:5000/new_session')
        >>> print post('http://localhost:5000/execute/0', {'code':'print(2+3)'})
        {
          "status": "ok", 
          "exec_id": 0, 
          "cell_status": "running"
        }
        >>> z = get('http://localhost:5000/killall')  # for doctesting
    """
    if files is None:
        files = {}
    else:
        files = dict([(k,StringIO(v)) if isinstance(v, basestring) else (k,v)
                      for k,v in files.iteritems()])
    if data is None: data = {}
    # This function with files!={} is easy because of "requests".
    return requests.post(url, data=data, timeout=timeout, files=files).text

def all_files(path):
    """
    Return a sorted list of the names of all files in the given path, and in
    all subdirectories.  Empty directories are ignored.

    INPUT:

    - ``path`` -- string

    EXAMPLES::

    We create 3 files: a, xyz.abc, and m/n/k/foo.  We also create a
    directory x/y/z, which is empty::

        >>> import tempfile
        >>> d = tempfile.mkdtemp()
        >>> o = open(os.path.join(d,'a'),'w')
        >>> o = open(os.path.join(d,'xyz.abc'),'w')
        >>> os.makedirs(os.path.join(d, 'x', 'y', 'z'))
        >>> os.makedirs(os.path.join(d, 'm', 'n', 'k'))
        >>> o = open(os.path.join(d,'m', 'n', 'k', 'foo'),'w')

    This all_files function returns a list of the 3 files, but
    completely ignores the empty directory::
    
        >>> all_files(d)       # ... = / on unix but \\ windows
        ['a', 'm...n...k...foo', 'xyz.abc']
    """
    all = []
    n = len(path)
    for root, dirs, files in os.walk(path):
        for fname in files:
            all.append(os.path.join(root[n+1:], fname))
    all.sort()
    return all


_temp_prefix = None
def is_temp_directory(path):
    """
    Return True if the given path is highly likely to have been
    generated by the tempfile.mktemp function.

    EXAMPLES::

        >>> import tempfile
        >>> is_temp_directory(tempfile.mktemp())
        True
        >>> is_temp_directory(tempfile.mktemp() + '../..')
        False
    """
    global _temp_prefix
    if _temp_prefix is None:
        _temp_prefix = os.path.split(tempfile.mktemp())[0]
    return os.path.split(os.path.abspath(path))[0] == _temp_prefix
