/*
Working with Google Cloud images.

The Google cloud api from https://www.npmjs.com/package/@google-cloud/compute for images
is in theory documented at:

- https://cloud.google.com/compute/docs/reference/rest/v1/images
- https://github.com/googleapis/google-cloud-node/blob/main/packages/google-cloud-compute/src/v1/images_client.ts

The only way to actually use it is really study the docs *and* the
autogenerated typescript definitions.

Do not bother with any LLM's, at least as of Sept 2023, as they all (Bard, GPT-4, etc.)
are incredibly wildly wrong about everything about @google-cloud/compute.  Hopefully
this will change someday, since it would be nice, and all the information to correctly
train those models is available on github.  But oh my god what a nightmare.

In any case, typescript for the win here.
*/

import { getCredentials } from "./client";
import { ImagesClient } from "@google-cloud/compute";
import TTLCache from "@isaacs/ttlcache";
import type {
  Architecture,
  GoogleCloudConfiguration,
} from "@cocalc/util/db-schema/compute-servers";
import { cmp } from "@cocalc/util/misc";
import { getGoogleCloudImagePrefix } from "./index";
import { imageDeprecation } from "@cocalc/server/compute/cloud/startup-script";

// Return the latest available image of the given type on the configured cluster.
// Returns null if no images of the given type are available.

function makeValid(s: string): string {
  return s.replace(/[._]/g, "-");
}

export async function imageName({
  image,
  tag,
  arch,
  gpu,
}: {
  image: string;
  tag: string;
  arch: Architecture;
  gpu?: boolean;
}) {
  if (!image) {
    throw Error("image must be specified");
  }
  if (!tag) {
    throw Error("tag must be specified");
  }
  if (!arch) {
    throw Error("arch must be specified");
  }
  return `${await getGoogleCloudImagePrefix()}-${makeValid(image)}-${makeValid(
    tag,
  )}${arch == "x86_64" ? "" : `-${arch}`}${gpu ? "-gpu" : ""}`; // _ not allowed
}

let client: ImagesClient | undefined = undefined;
let projectId: string | undefined;
export async function getImagesClient() {
  if (client != null && projectId != null) {
    return { client, projectId };
  }
  const credentials = await getCredentials();
  client = new ImagesClient(credentials);
  projectId = credentials.projectId as string;
  return { client, projectId };
}

// filters are documented at https://cloud.google.com/sdk/gcloud/reference/topic/filters/
// and "The matching is anchored and case insensitive. An optional trailing * does a
// word prefix match."

const imageCache = new TTLCache({ ttl: 60 * 1000 });

type ImageList = {
  name: string;
  labels: object;
  diskSizeGb: string;
  creationTimestamp: string;
}[];

export async function getAllImages({
  image,
  arch,
  sourceImage,
  labels,
}: {
  image?: string;
  arch?: Architecture;
  sourceImage?: string;
  labels?: object;
}): Promise<ImageList> {
  let prefix;
  if (image == null) {
    // gets all images
    prefix = `${await getGoogleCloudImagePrefix()}-`;
  } else {
    // fix for when we rename images
    image = imageDeprecation(image);
    if (image == null) {
      throw Error("bug");
    }
    if (arch == null) {
      throw Error("if image is given, then arch must also be specified");
    }
    // restrict images by image and arch
    prefix = await imageName({ image, arch });
    if (sourceImage) {
      prefix = `${prefix}-${sourceImage}`;
    }
  }
  const cacheKey = JSON.stringify({ image, arch, labels });
  if (imageCache.has(cacheKey)) {
    return imageCache.get(cacheKey)!;
  }
  const { client, projectId } = await getImagesClient();
  let filter = `name:${prefix}*`;
  if (labels != null) {
    for (const key in labels) {
      filter += ` AND labels.${key}=${labels[key]} `;
    }
  }
  const [images] = await client.list({
    project: projectId,
    maxResults: 1000,
    filter,
  });
  imageCache.set(cacheKey, images as ImageList);
  return images as ImageList;
}

// Returns true if the image currently exists; false, otherwise.
export async function imageExists(name: string): Promise<boolean> {
  const { client, projectId } = await getImagesClient();
  const filter = `name:${name}`;
  const [images] = await client.list({
    project: projectId,
    maxResults: 1,
    filter,
  });
  return images.length > 0;
}

export function getArchitecture(machineType: string): Architecture {
  return machineType.startsWith("t2a-") ? "arm64" : "x86_64";
}

type ImageFilter = Partial<GoogleCloudConfiguration> & {
  prod?: boolean;
  arch?: Architecture;
};

export async function getNewestSourceImage(opts: ImageFilter): Promise<{
  sourceImage: string;
  diskSizeGb: number;
}> {
  const images = await getSourceImages(opts);
  if (images.length == 0) {
    throw Error(
      `no images are available for ${opts.image} ${opts.arch ?? "x86_64"} ${
        opts.prod
          ? "that are labeled prod=true"
          : " with no constraint on prod label"
      }`,
    );
  }
  return images[0];
}

export async function getSourceImages({
  image,
  machineType,
  sourceImage,
  prod,
  arch,
}: ImageFilter = {}): Promise<
  {
    sourceImage: string;
    diskSizeGb: number;
  }[]
> {
  if (arch == null) {
    arch = machineType ? getArchitecture(machineType) : undefined;
  }
  const images = await getAllImages({
    image,
    arch,
    sourceImage,
    labels: !prod || sourceImage ? undefined : { prod: true },
  });
  // sort by newest first; note that creationTimestamp is an iso date string
  images.sort((a, b) => -cmp(a.creationTimestamp, b.creationTimestamp));
  const { projectId } = await getCredentials();
  return images.map(({ name, diskSizeGb }) => {
    return {
      sourceImage: `projects/${projectId}/global/images/${name}`,
      diskSizeGb: parseInt(diskSizeGb),
    };
  });
}

export async function labelSourceImages({
  filter,
  key = "prod",
  value = true,
}: {
  filter: ImageFilter;
  key;
  value;
}) {
  for (const { sourceImage: name } of await getSourceImages(filter)) {
    await setImageLabel({ name, key, value });
  }
}

// name = exact full name of the image
export async function setImageLabel({
  name,
  key,
  value,
}: {
  name: string;
  key: string;
  value: string | null | undefined;
}) {
  // console.log("setImageLabel", { name, key, value });
  const { client, projectId } = await getImagesClient();
  const i = name.lastIndexOf("/");
  if (i != -1) {
    name = name.slice(i + 1);
  }
  const [image] = await client.get({
    project: projectId,
    image: name,
  });
  let labels, labelFingerprint;
  ({ labels, labelFingerprint } = image);
  if (labels == null) {
    labels = {};
  }
  if (value == null) {
    if (labels[key] == null) {
      // nothing to do
      return;
    }
    delete labels[key];
  } else {
    labels[key] = `${value}`;
  }

  await client.setLabels({
    project: projectId,
    resource: name,
    globalSetLabelsRequestResource: {
      labels,
      labelFingerprint,
    },
  });
}
