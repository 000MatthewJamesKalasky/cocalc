/*
Working with Google Cloud images.

The Google cloud api from https://www.npmjs.com/package/@google-cloud/compute for images
is in theory documented at:

- https://cloud.google.com/compute/docs/reference/rest/v1/images
- https://github.com/googleapis/google-cloud-node/blob/main/packages/google-cloud-compute/src/v1/images_client.ts

The only way to actually use it is really study the docs *and* the
autogenerated typescript definitions.

Do not bother with any LLM's, at least as of Sept 2023, as they all (Bard, GPT-4, etc.)
are incredibly wildly wrong about everything about @google-cloud/compute.  Hopefully
this will change someday, since it would be nice, and all the information to correctly
train those models is available on github.  But oh my god what a nightmare.

In any case, typescript for the win here.
*/

import { createDatabaseCache } from "@cocalc/server/compute/database-cache";
import { getCredentials } from "./client";
import { ImagesClient } from "@google-cloud/compute";
import type {
  Architecture,
  GoogleCloudConfiguration,
  GoogleCloudImage,
  GoogleCloudImages,
} from "@cocalc/util/db-schema/compute-servers";
import { cmp } from "@cocalc/util/misc";
import { getGoogleCloudImagePrefix } from "./index";
import { imageDeprecation } from "@cocalc/server/compute/cloud/startup-script";
import { COMPUTE_SERVER_IMAGES } from "@cocalc/server/compute/images";

// Return the latest available image of the given type on the configured cluster.
// Returns null if no images of the given type are available.

function makeValid(s: string): string {
  return s.replace(/[._]/g, "-");
}

export async function imageName({
  image,
  tag,
  arch,
  gpu,
}: {
  image: string;
  tag: string;
  arch: Architecture;
  gpu?: boolean;
}) {
  if (!image) {
    throw Error("image must be specified");
  }
  if (!tag) {
    throw Error("tag must be specified");
  }
  if (!arch) {
    throw Error("arch must be specified");
  }
  return `${await getGoogleCloudImagePrefix()}-${makeValid(image)}-${makeValid(
    tag,
  )}${arch == "x86_64" ? "" : `-${arch}`}${gpu ? "-gpu" : ""}`; // _ not allowed
}

let client: ImagesClient | undefined = undefined;
let projectId: string | undefined;
export async function getImagesClient() {
  if (client != null && projectId != null) {
    return { client, projectId };
  }
  const credentials = await getCredentials();
  client = new ImagesClient(credentials);
  projectId = credentials.projectId as string;
  return { client, projectId };
}

// filters are documented at https://cloud.google.com/sdk/gcloud/reference/topic/filters/
// and "The matching is anchored and case insensitive. An optional trailing * does a
// word prefix match."

// 1 hour default ttl -- data stored in the database,
// and some operations like building new images
// update this.
const TTL_MS = 1000 * 60 * 60;
const GOOGLE_CLOUD_IMAGES_SERVER_SETTINGS = `${COMPUTE_SERVER_IMAGES}-google-cloud`;

export const getAllImages = createDatabaseCache<{
  [name: string]: GoogleCloudImage;
}>({
  TTL_MS,
  NAME: GOOGLE_CLOUD_IMAGES_SERVER_SETTINGS,
  fetchData: fetchImagesFromGoogleCloud,
});

async function fetchImagesFromGoogleCloud({
  labels,
}: {
  labels?: object;
} = {}): Promise<GoogleCloudImages> {
  const prefix = `${await getGoogleCloudImagePrefix()}-`;
  const { client, projectId } = await getImagesClient();
  let filter = `name:${prefix}*`;
  if (labels != null) {
    for (const key in labels) {
      filter += ` AND labels.${key}=${labels[key]} `;
    }
  }
  const [images] = await client.list({
    project: projectId,
    maxResults: 2000, // should never be close to this.
    filter,
  });

  // there's a lot of extra info in images that we don't need to store.
  const data: GoogleCloudImages = {};
  for (const { name, labels, diskSizeGb, creationTimestamp } of images) {
    if (!name) continue;
    data[name] = {
      labels,
      diskSizeGb: parseInt(diskSizeGb as string),
      creationTimestamp,
    } as unknown as GoogleCloudImage;
  }
  return data;
}

// Returns true if the image currently exists; false, otherwise.
export async function imageExists(name: string): Promise<boolean> {
  const { client, projectId } = await getImagesClient();
  const filter = `name:${name}`;
  const [images] = await client.list({
    project: projectId,
    maxResults: 1,
    filter,
  });
  return images.length > 0;
}

export function getArchitecture(machineType: string): Architecture {
  return machineType.startsWith("t2a-") ? "arm64" : "x86_64";
}

export async function getSourceImage({
  image,
  tag,
  machineType,
  acceleratorType,
  acceleratorCount,
}: GoogleCloudConfiguration): Promise<{
  sourceImage: string;
  diskSizeGb: number;
}> {
  image = imageDeprecation(image);
  const arch = getArchitecture(machineType);
  const gpu = !!acceleratorType && !!acceleratorCount;
  const googleImages = await getAllImages();
  const { projectId } = await getCredentials();

  if (tag) {
    const name = await imageName({ image, tag, arch, gpu });
    const x = googleImages[name];
    return {
      sourceImage: `projects/${projectId}/global/images/${name}`,
      diskSizeGb: x.diskSizeGb,
    };
    // failed to find image with the exactly specified tag.
    throw Error(
      `Prebuilt image tag='${tag}' not available -- please change the image version in advanced settings`,
    );
  }
  // choose source based on what is available -- best tested image if there is one;
  // otherwise, an untested image.  This is mainly for old compute servers, since newer
  // ones are likely to have the tag set.
  const options: (GoogleCloudImage & { name: string })[] = [];
  for (const name in googleImages) {
    if (name.startsWith(image)) {
      options.push({ name, ...googleImages[name] });
    }
  }
  // best at beginning
  options.sort((a, b) => {
    const a_tested = a.labels?.["tested"];
    const b_tested = b.labels?.["tested"];
    if (a_tested && !b_tested) {
      // a is better
      return -1;
    }
    if (b_tested && !a_tested) {
      // b is better
      return 1;
    }
    // compare based on timestamp
    return -cmp(a.creationTimestamp, b.creationTimestamp);
  });
  if (options.length > 0) {
    const x = options[0];
    return {
      sourceImage: `projects/${projectId}/global/images/${x.name}`,
      diskSizeGb: x.diskSizeGb,
    };
  }
  throw Error(`No prebuilt image for '${image}' -- please change the image`);
}

// name = exact full name of the image
export async function setImageLabel({
  name,
  key,
  value,
}: {
  name: string;
  key: string;
  value: string | null | undefined;
}) {
  // console.log("setImageLabel", { name, key, value });
  const { client, projectId } = await getImagesClient();
  const i = name.lastIndexOf("/");
  if (i != -1) {
    name = name.slice(i + 1);
  }
  const [image] = await client.get({
    project: projectId,
    image: name,
  });
  let labels, labelFingerprint;
  ({ labels, labelFingerprint } = image);
  if (labels == null) {
    labels = {};
  }
  if (value == null) {
    if (labels[key] == null) {
      // nothing to do
      return;
    }
    delete labels[key];
  } else {
    labels[key] = `${value}`;
  }

  await client.setLabels({
    project: projectId,
    resource: name,
    globalSetLabelsRequestResource: {
      labels,
      labelFingerprint,
    },
  });
}
