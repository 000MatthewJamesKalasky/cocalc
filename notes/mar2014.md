# VM's:

# TOP PRIORITY

 - [ ] rewrite hub so it uses new project system when project has a certain setting in db, testing on this new server...

    This is what is used now:

         - open_project_somewhere
         - close project
         - save project
         - create_project
         - last_snapshot
         - snapshot project
         - snapshot_listing
         - close_stale_projects
         - storage status

    Plan:

     - [x] add flag to projects table for "storage2 project" -- when set, fully use new storage system everywhere.

     - [ ] rsync of the .sagemathcloud template, i.e., only thing

  - [ ] remove storage account completely, and also the create_project_user.py script (and similar ones) in /usr/local/bin/.  Move the zpool status crontab stuff to salvus user. 

  - [ ] storage_server: for *next round* of migrate_delete, need to delete storage/streams path first, due to the above... or at least change the sync code to check filesize.

  - [ ] storage: re-image project, which means replace all the sparse image files by one new image file, possibly of a different size; can/will save space

  - [ ] storage: re-compact: replace all streams by a single big stream; throws away some history so can save space/time, but means caches have to be recreated.

  - [ ] transition everything from my salvus keyspace on old cassandra cluster to new database, cleaning up the tables/schemas in the process
           this took 1 minute:
                   copy salvus.projects (project_id,account_id,title) to 'projects.csv';

  - [ ] storage_server: make it so can limit the number of simultaneous ZFS operations (?)

## BACKUPS ##

   - [ ] implement a different offsite backup system of *cassandra* via incrementals of one data center.
         We could recover from anything using these by rebuilding the nodes.  Once I merge the
         two cassandra db's, this would provide a complete backup of everything.
         Just follow this: http://www.datastax.com/documentation/cassandra/2.0/cassandra/operations/ops_backup_restore_c.html

    1. I just did "nodetool snapshot storage -t 2014-03-12" on all padelford nodes at once. -- took about 10 seconds.
    2. I'm doing this on bsd.math, which is writing data at a rate of about 2GB/minute.

        time rsync -axvH cloud3:/home/salvus/vm/images/storage/storage/storage_chunks/snapshots/2014-03-12/ 10.1.3.1/home/salvus/vm/images/storage/storage/storage_chunks/snapshots/2014-03-12/

    3. There are 2.8TB to backup right now, and the target USB disk is 3.7TB.  At this rate, that will take 1400 minutes, or "one day".  WOW.    After making the initial backups, additional ones will be incrementals, which are easy.
       If I keep two copies of this data, I could easily do a complete restore from scratch in 1 day.  That satisfies my requirements.


        time rsync -axvH cloud2:/home/salvus/vm/images/storage/storage/storage_chunks/snapshots/2014-03-12/ 10.1.3.1/home/salvus/vm/images/storage/storage/storage_chunks/snapshots/2014-03-12/

    4. (started March 12 at 4pm) Now using this script with target an *encrypted sparseimage*:

    bsd:database salvus$ more backup.py

            #!/usr/bin/env python

            # make encrypted disk with
            #  sudo hdiutil create -size 3.5t -encryption -type sparse -fs hfs= smc-offsite-2-encrypted

            import os, time


            def cmd(s):
                print s
                os.system(s)

            hosts=[('cloud%s'%i,'10.1.%s.1'%i) for i in [1,2,3,4,5,6,7]]

            snapshot = '2014-03-12'

            for hostname, name in hosts:
                for keyspace in ['storage']:
                    for table in ['storage','storage_log','storage_writing', 'storage_chunks']:
                        path = "/home/salvus/vm/images/storage/%s/%s/snapshots/%s/"%(keyspace,table,snapshot)
                        cmd("mkdir -p %s/%s"%(name,path))
                        cmd("time rsync -axvH %s:%s %s%s &"%(hostname,path,name,path))

    Once the above finishes and works, I'll delete this snapshot and make a brand new one to a different bigger USB drive, and offsite the first.
    Let's get this process going.

    And once I move all data into the same database, we'll hence have excellent backups, with a solid restore process.

    1.5 hours = 172GB, so 2800GB will take about 25 hours.  nice.

#####


- [ ] fix this for GOOD!  (line 113 bs)
        salvus@web10:~/salvus/salvus$ vi /home/salvus/salvus/salvus/node_modules/http-proxy/lib/http-proxy/passes/ws-incoming.js

- [ ] change hosts to use UTC

- [ ] fix pexpect issue: https://mail.google.com/mail/u/0/?shva=1#inbox/144a87737d982c93

- [ ] rebooting the GCE nodes seems to never succeeds so write the command line code to recreate them.

- [x] finish first round of migrating projects from -- 3,5,6 (then re-enable for users in database)

- [x] storage: better schedule for applying streams, which does the right thing when forks happen, multiple start times, etc.  I.e., no matter what even when we don't delete streams.   Basically, we start with the stream with the newest end time, then work back until hitting a stream with 0 interval.   Make *that* the only thing returned by the "def streams" function.

- [x] storage: trim function that goes through and deletes all (non-fork) streams that would not be applied (except forks)


# LATER


# OPS

- [ ] add something to monitor somehow that informs me if hubs have tracebacks!
- [ ] get rid of updatedb from
- [ ] monitor: free space on / and vm/images/ filesystems on host!


# UI

- [ ] when opening a sagews file, if sage won't run, still open the file, but with a warning that Sage doesn't work.

- [ ] solid simple GUI editor for %html: https://github.com/guardian/scribe



# DONE

- [x] restore the internal firewalling on compute VM's, namely disallow connections on user ports from anywhere except a
      specific whitelist of external hub VM's.  Right now, it's mainly security by obscurity.
          https://mail.google.com/mail/u/0/?shva=1#inbox/1448b75264eeda11


- [x] storage.coffee: replicate (as storage user, using storage project)

- [x] official ipython upgrade: http://trac.sagemath.org/ticket/14713    ; running tests in scratch on compute13a


- [x] storage: should I use a database (+local streams cache) in order to separate compute from storage, which will make compute much, much more dynamically scalable?  ANS -- YES

   - [x] (2:00?) (12:00 --yep 12 hours) write code to split (into small pieces) and save (in parallel) a big object to the database and test.
         - I wrote this demo code.
         - When saving in parallel (with many threads) I guess across the C* cluster, it's about the same as rsync/scp, but seems more robust:
               it's about 10MB/s across my encrypted network/vpn.
         - can't load a big file directly into memory -- will have to do something with streaming and chunking (more complicated code)
         - I think this is viable, but as a separate keyspace (for security and to use a different replication factor)
         - This will be the long-term storage of projects.   We can still cache on local disk.  But view that only as a cache.
         -

    CREATE KEYSPACE storage WITH replication = {'class': 'NetworkTopologyStrategy', 'DC0': '2', 'DC1': '2'};
    CREATE USER storage0 WITH PASSWORD='random...';
    GRANT ALL ON KEYSPACE storage TO storage0;



- [x] cassandra -- redo to use ZFS -- e.g., 5,6,7 will save 100's of GB's of space (and we could use it there).

DONE: 1,2,5,6,7,4,3,10,11,12,13,14,15,
TODO: 16,17,18,19,20,21


n=7
import admin; reload(admin); cloud = admin.Services('conf/deploy_cloud/'); h = lambda x: cloud._hosts('cassandra%s'%n, x, sudo=True, timeout=3600)
cloud.restart('vm',hostname='cassandra%s'%n)  # may take doing it multiple times...
cloud.wait_until_up('10.1.%s.2'%n)

h('zpool create -f cassandra /dev/vdc')
h('zfs set compression=lz4 cassandra')
h('zfs set atime=off cassandra')
h('zfs set logbias=throughput cassandra')
h('rsync -axH /mnt/cassandra/ /cassandra/')
h('umount /mnt/cassandra')
h('zfs set mountpoint=/mnt/cassandra cassandra')
h('zfs snapshot cassandra@init')
h('zpool export cassandra')

--> Which is the same as log in and...

    # fdisk /dev/vdc
    zpool create -f cassandra /dev/vdc
    zfs set compression=lz4 cassandra
    zfs set atime=off cassandra
    zfs set logbias=throughput cassandra
    time sudo rsync -axH /mnt/cassandra/ /cassandra/
    umount /mnt/cassandra
    zfs set mountpoint=/mnt/cassandra cassandra
    zfs snapshot cassandra@init
    zpool export cassandra


--> remove the old image from services file, then

import admin; reload(admin); cloud = admin.Services('conf/deploy_cloud/'); h = lambda x: cloud._hosts('cassandra%s'%n, x, sudo=True, timeout=3600)

cloud.restart('vm',hostname='cassandra%s'%n)
cloud.wait_until_up('10.1.%s.2'%n)
h('zpool import -f cassandra')
cloud.start('cassandra',host='cassandra%s'%n,wait=True)

print cloud._hosts('cassandra%s'%n, 'cd ~/salvus/salvus; . salvus-env; nodetool status', wait=True)


---> Once it is working, move the cassandra-cassandra.img to TRASH.

---
    Net result for cassandra5 -- it takes up 2.2G on disk instead of 150G :-)

        150G    cassandra5-cassandra.img
        2.2G    cassandra5-cassandra-zfs.img

    And migrating to an encrypted SSD device later will be easy (zfs send/recv).  Plus I can snapshot all nodes for a backup-in-place.
    And I can also make offsites of all nodes via zfs send.

---

- [x] build sage-6.2.beta with ipython update:  git fetch git://git.sagemath.org/sage.git u/ohanar/ipython-upgrade
            use system-wide atlas so it's fast to build and portable.
      - [x] ensure clawpack fully works in new sage version
      - [x] more useful crontab monitoring pools:
            */5 * * * * sudo zpool list projects > /home/storage/.zpool.list.projects && cp /home/storage/.zpool.list.projects /home/storage/zpool.list.projects
            */5 * * * * sudo zpool list storage > /home/storage/.zpool.list.storage&& cp /home/storage/.zpool.list.storage /home/storage/zpool.list.storage
            */5 * * * * sudo zpool list cassandra > /home/storage/.zpool.list.cassandra && cp /home/storage/.zpool.list.cassandra /home/storage/zpool.list.cassandra
      - [x] make storage user have more sudo powers:
            # to manage the zfs pool for other projects
            storage ALL=(ALL) NOPASSWD: /sbin/zfs *
            storage ALL=(ALL) NOPASSWD: /sbin/zpool *
            storage ALL=(ALL) NOPASSWD: /usr/bin/pkill *
            # to create users for projects
            storage ALL=(ALL) NOPASSWD: /usr/local/bin/create_project_user.py *
      - [x] automate put latest smc_storage.py in /home/storage/



   - [x] create a new ZFS pool on each compute machine called "storage" with filesystems -- no dedup and no compression.
        storage/images
        storage/streams

        zpool create storage -f /dev/vdd
        zfs set sync=disabled storage
        zfs create storage/images
        zfs create storage/streams
        chown salvus. /storage/streams
        chown salvus. /storage/images
        chmod og-rwx /storage/streams
        chmod og-rwx /storage/images


        zpool export storage

    (x) done at UW

- [x] create 425GB/each storage devices on all of 3.1.x.4 for x=1,2,..,8, attach and configure (with care!)
      (only 8 remains)

- [x] export and delete storage on 3.1.x.4 for x=1,2,3.
- [x] create zpool image ubuntu-base-salvus-qcow, and copy over data.

- [x] pexpect bug -- fix in base image and update
       /usr/local/sage/sage-6.2/local/lib/python2.7/site-packages/pexpect.py

- [x] transition the 8 compute machines at Google from Debian to Ubuntu:
       - [x] setup compute-base-disk and run doctests
       - [x] worry about startup script and switch 10.3.4.4 first, since no projects are running there.
          - [x] 10.3.4.4
          - [x] 10.3.3.4
          - [x] 10.3.1.4
          - [x] 10.3.2.4
          - [x] 10.3.5.4
          - [x] 10.3.6.4
          - [x] 10.3.7.4
          - [x] 10.3.8.4

ssh-keygen -f "/home/salvus/.ssh/known_hosts" -R 10.3.1.4; ssh-keygen -f "/home/salvus/.ssh/known_hosts" -R 10.3.2.4; ssh-keygen -f "/home/salvus/.ssh/known_hosts" -R 10.3.3.4; ssh-keygen -f "/home/salvus/.ssh/known_hosts" -R 10.3.4.4; ssh-keygen -f "/home/salvus/.ssh/known_hosts" -R 10.3.5.4; ssh-keygen -f "/home/salvus/.ssh/known_hosts" -R 10.3.6.4; ssh-keygen -f "/home/salvus/.ssh/known_hosts" -R 10.3.7.4; ssh-keygen -f "/home/salvus/.ssh/known_hosts" -R 10.3.8.4


 - [x] Make sure to do this: "zfs set sync=disabled storage" on storage1-8 on gce nodes.

- [x] (1:03) fix bug with raw http server failing.

The top of the log for a failed project is:

    start debug: info: starting tcp serverdebug: read '/proinfo: listening on port 40414
    info: starting raw server...
    info: raw server (port=47050), host='10.1.16.4', base='/3702601d-9fbc-4e4e-b7ab-c10a79e34d3b/raw/'
    sername":"3702601d9fbc4e4eb7abc10a79e34d3b","path":".","host":"10.1.16.4","port":22},"base_url":""}
    error: Uncaught exception: Error: listen EADDRNOTAVAIL
    Trace
        at process.daemon.pidFile (/projects/3702601d-9fbc-4e4e-b7ab-c10a79e34d3b/.sagemathcloud/node_modules/local_hub.js:2160:24)
        at process.EventEmitter.emit (events.js:126:20)
    debug: PARENT: received connection
    debug: PARENT: received connection
    debug: received control mesg {"event":"codemirror_get_session","path":"./.sagemathcloud.log","project_id":"3702601d-9fbc-4e4e-b7ab-c10a79e34d3b","id
    ":"ce075976-4157-4c87-847e-05d57d8397c3"}

(1) what is this /proinfo thing?



- [x] try setting up a cassandra 2.x storage cluster from scratch on *bare metal* (/dedicated public ip GCE's there later) with everything SSL encrypted.

   - [x] read security section of docs
   - [x] <http://www.datastax.com/documentation/cassandra/2.0/cassandra/install/installDeb_t.html>

           add-apt-repository ppa:webupd8team/java; apt-get update; apt-get install oracle-java7-installer libjna-java
               # if the above goes wrong, do this:
               #  rm /var/lib/dpkg/info/oracle-java7-installer*; apt-get purge oracle-java7-installer*; rm /etc/apt/sources.list.d/*java*

           echo "deb http://debian.datastax.com/community stable main" | sudo tee -a /etc/apt/sources.list.d/cassandra.sources.list
           curl -L http://debian.datastax.com/debian/repo_key | sudo apt-key add -
           apt-get update; apt-get install dsc20; service cassandra stop; rm -rf /var/lib/cassandra/data/system/*
           rm /etc/rc2.d/S50cassandra     # so doesn't auto-start -- do that manually depending on node hostname

   - [x] setup insecure cassandra 2.x cluster for testing.

       created and put in /etc/cassandra/
            salvus/conf/deploy_cloud/storage/*.yaml

            NOTE!! -- I forgot to put: "auto_bootstrap: false" at the bottom of cassandra.yaml, which costs me about 2 hours. DANG.

       data location:
            mkdir /home/salvus/vm/images/storage
            chown -R cassandra. /home/salvus/vm/images/storage

       start the seed nodes one at a time, and then start the rest of the nodes:
            service cassandra start
            tail -f /var/log/cassandra/system.log

   - [x] test/benchmark writing using my storage system:
          my 1.4GB blob:
            limit   chunk_size      write        read
              5         10          35-55           51
              5         64          56
          Basically it takes about 55 seconds to send 1400MB.
          To send with scp is about the same.
          With iperf it would be about 18 seconds (?), so there
          is a lot of encryption overhead, evidently.

          Reading and sending are at about the same speed, but one has to happen before the other can... hmm.

          I just tried storing a 380MB file via the DB in cassandra versus my bare metal setup... and
          it took 94s on VM's and 14s on bare metal...

          So this is a GO.

          Testing pushing projects 0-999 into the DB to see how that goes tomorrow morning...





- [x] upgrade python:

   sage -sh
   umask 022; easy_install -U distribute
        # pip install --upgrade clawpack   ## NOT YET

- [x] temporary (line 113 bs)
        salvus@web10:~/salvus/salvus$ vi /home/salvus/salvus/salvus/node_modules/http-proxy/lib/http-proxy/passes/ws-incoming.js



- [x] benchmark a cassandra setup on raw hardware but over VPN: it's 90 seconds to write my 1.4GB test file instead of 60 seconds.
by the way:
salvus@cloud3:~/salvus/salvus$ time openssl aes-128-cbc -in blob -out blob.ssl -pass file:blah
real    0m16.047s

- [x] setup clean cassandra server

- [x] write table that records only active writes

x={};require('cassandra').storage_db((e,d)->x.d=d;x.c=x.d.chunked_storage(id:'3702601d-9fbc-4e4e-b7ab-c10a79e34d3b') )



- [x] write scrub command that deletes anything that is in the active table, but is sufficiently old (based on timestamp)

- [x] during the save this sometimes happens (when pushing load hard):  Make it retry with exponential backoff... like the Netflix code does.
    coffee> error: Query cql('UPDATE storage_chunks SET chunk=?, size=? WHERE chunk_id=?',params=[[16,138,14,232,246,161,0,253,95,133,...) caused a CQL error:
    ResponseError: Operation timed out - received only 0 responses.
    s.verbose=1


- [x] rewrite database code to not use find -- ugly; doesn't clean up properly...
        debug: execute_code: "find /home/salvus/streams//06049aff-157e-4cf1-9f72-adf1aafcd29e -type f -printf %s %P
        "
        debug: Spawn the command find with given args /home/salvus/streams//06049aff-157e-4cf1-9f72-adf1aafcd29e,-type,f,-printf,%s %P
        events.js:72
                throw er; // Unhandled 'error' event
                      ^
        Error: spawn EMFILE
            at errnoException (child_process.js:980:11)
            at ChildProcess.spawn (child_process.js:927:11)
            at Object.exports.spawn (child_process.js:715:9)
            at async.series.exit_code (/home/salvus/salvus/salvus/node_modules/misc_node.js:334:27)
            at /home/salvus/salvus/salvus/node_modules/async/lib/async.js:548:21

    These tests suggest it does work fine:

        coffee> m=require('misc_node');async=require('async');0;
        0
        coffee> f=(i,c)->m.execute_code(command:'find', args:['/tmp/'], cb:(e,out)->c(e))
        [Function]
        coffee> async.mapSeries([0..1000],f,(e)->console.log(e))
        undefined
        coffee> null



- [x] I was able to trigger the find error by pushing the entire directory tree of `node_modules` twice... but the problem was due to not closing fd when calling put.  Very important to fix this.

- [x] error storing a too-large file:

        debug: storage_migrate: done syncing 00bffa4f-314b-4d33-b46c-5b8a1bf78161 in 7.086999893188477 seconds
        DONE { '006a0178-f833-40f0-8fbf-fc6326d482d2':
           { name: 'ResponseError',
             message: 'unable to make int from \'2529408766\'',
             info: 'Represents a error message from the server',
             code: 8704,
             isServerUnhealthy: false,

    change size type to bigint fixes.


- [x] add user/password auth to db:

        ALTER KEYSPACE system_auth WITH REPLICATION = {'class' : 'NetworkTopologyStrategy', 'DC0' : 3, 'DC1' : 3};


- [x] move compute5 data from cloud5 to cloud2 for now, since it is so huge and that disk will run out soon.
  - [x] copy all projects into database

  - [x] write `storage_server` TCP server:

     - [x] create storage_server user and account and password with limited permissions.
        CREATE USER storage_server WITH PASSWORD '...';
        GRANT MODIFY ON table storage TO storage_server;
        GRANT MODIFY ON table storage_writing TO storage_server;
        GRANT MODIFY ON table storage_chunks TO storage_server;
        GRANT MODIFY ON table storage_servers TO storage_server;
        GRANT SELECT ON table storage TO storage_server;
        GRANT SELECT ON table storage_writing TO storage_server;
        GRANT SELECT ON table storage_chunks TO storage_server;
        GRANT SELECT ON table storage_servers TO storage_server;
        GRANT SELECT ON table storage_log TO storage_server;
        GRANT MODIFY ON table storage_log TO storage_server;
        GRANT SELECT ON table project_storage  TO storage_server;
        GRANT MODIFY ON table project_storage  TO storage_server;
        GRANT SELECT ON table project_storage_host TO storage_server;
        GRANT MODIFY ON table project_storage_host TO storage_server;

  - [x] enough sudo to migrate as salvus user

   - [x] mkdir -p /usr/local/sage/sage-6.2/local/share/sage/ext/octave/user; chmod a+rwx /usr/local/sage/sage-6.2/local/share/sage/ext/octave/user
   - [x] update salvus repo
   - [x] update visudo as smc_storage.py
  - [x] start storage_servers running on all compute vm's.



new vm image:

  - [x] logging for storage
  - [x] storage_server: robustness of client when the remote server dies/moves to another port
  - [x] run migrate_delete on some projects as a test:
            - doing it on projects with location = 1
            - doing it on projects with location = 13

   2 errors on 13, none on 1:  ["7bbb2a01-61e0-4d33-932f-07d38013a9f6","5e6b5009-04e7-4bd4-bca4-96071bca5605"]
      - the first seems clearly a ZFS BUG :-(, which only a reboot will fix...
      - second had messed up sparse image -- adding delete to api fixed problems.



  - [x] code to update migration of a given project using a given host:

  Steps for migration update, which should be command in `storage_server`, which gets removed.  Can be unsafe for now.

     - sync from db to local
     - if any files there, mount and call migrate_snapshots
     - if no files there, call migrate
     - call sync_put_delete

  - [ ] design change: consider having the streams cache in a normal directory and the images zpool separate from this.
        - On boot-up, we could simply create the images pool from scratch each time.
        - Alternatively, maybe just ensure that there are at most n images/project-id filesystems, and destroy old ones.


  - [x] update all storage servers with newer code and restart


  - [x] add 4-node n1-highmem-2 + 1TB disk google DC to storage cassandra cluster:
       <http://www.datastax.com/documentation/cassandra/2.0/cassandra/operations/ops_add_dc_to_cluster_t.html>
          - make my snapshot image have newest cassandra-2.0.5 system-wide

                ALTER KEYSPACE "storage" WITH REPLICATION = {'class': 'NetworkTopologyStrategy', 'DC0':'2', 'DC1':'2', 'DC2':'2'};

          - Did "nodetool repair -pr" simultaneously on new nodes, so they're getting data.  It looks like this will take
            about one week.  I'm glad I started now.

  - [x] make change so `storage_server`'s connect exactly to the cassandra servers in *their* data center only.
   - [X] FAIL -- try bup-based backup of everything:
      - the exact files from the DB, for relatively fast restore,
      - provides point-in-time, and also easy incrementals to offsite.
      - *maybe* the deduplication would divide out the replication factor (!); we'll see.
      - the pack files could easily be encrypted... after the fact
      - to test them, we could restore to a testing cluster, which would also be useful for testing purposes.
      ... BUT --  it is a total fail: "Saving: 0.04% (172299/444825403k, 167/595 files) 1302h4m 92k/s"

   - [x] implement a new offsite backup system, which could just involve --
            (1) add a new table storage_write_log that is like the storage_log, but with a ttl, which only records writes
            (2) make a backup machine that can read (but not write!) from the database, which scans that
                table regularly, and sync_get's each modified project to a local directory (the offsite backup).
         - a problem with this is that it's not a complete backup of the whole database (e.g., project, accounts, etc.)
         - it would take a very long time to recover, since the data must be re-read into the database, which is complicated
           and time consuming.




  - [x] get needs to write to a temp file, then move it over -- destroy on fail.
  - [x] this is hanging forever when server isn't running:
        debug: Storage client (undefined:undefined): connect to locked socket
        debug: misc_node: connecting to a locked socket on port 37401...
  - [x] coffee> debug: storage Client(undefined:44646).call({"mesg":{"event":"storage","project_id":"e53d0f98-f674-4569-aa8d-66fac50c61a5","action":"sync","id":"75d1
71ed-5672-4490-b452-a3e4ac4b83eb"},"timeout":3600}): got response -- {"event":"error","id":"75d171ed-5672-4490-b452-a3e4ac4b83eb","error":"No row in table 's
torage' matched condition '[object Object]'","result":[null,null,null,null,[null]],"time_s":28.618000030517578}
No row in table 'storage' matched condition '[object Object]' undefined

- [ ] admin monitor FAIL:

        Connected to 10.1.6.2
        ---------------------------------------------------------------------------
        OperationalError                          Traceback (most recent call last)
        <ipython-input-4-dce543985046> in <module>()
        ----> 1 cloud.monitor.go(15,7)

        /home/salvus/salvus/salvus/admin.pyc in go(self, interval, residue)
           1565                 if now % interval == residue:
           1566                     last_time = now
        -> 1567                     self._go()
           1568             time.sleep(20)
           1569

        /home/salvus/salvus/salvus/admin.pyc in _go(self)
           1533     def _go(self):
           1534         all = self.all()
        -> 1535         self.update_db(all=all)
           1536         self.print_status(all=all)
           1537         down = self.down(all=all)

        /home/salvus/salvus/salvus/admin.pyc in update_db(self, all)
           1509         # Fill in disabled field for each compute node; this is useful to record in
           1510         # the monitor, and is used by the move project UI code.
        -> 1511         v = dict(list(cassandra.cursor_execute("SELECT host,disabled FROM storage_topology", user='monitor', password=password)))
           1512         if 'compute' in all:
           1513             for x in all['compute']:

        /home/salvus/salvus/salvus/cassandra.pyc in cursor_execute(query, param_dict, keyspace, timeout, user, password)
            114             print msg
            115             cur = cursor(keyspace=keyspace, use_cache=False, user=user, password=password)
        --> 116             cur.execute(query, param_dict)
            117     finally:
            118         signal.signal(signal.SIGALRM, signal.SIG_IGN)

        /home/salvus/salvus/salvus/data/local/lib/python2.7/site-packages/cql/cursor.pyc in execute(self, cql_query, params, decoder, consistency_level)
             78         prepared_q = self.prepare_inline(cql_query, params)
             79         cl = consistency_level or self.consistency_level
        ---> 80         response = self.get_response(prepared_q, cl)
             81         return self.process_execution_results(response, decoder=decoder)
             82

        /home/salvus/salvus/salvus/data/local/lib/python2.7/site-packages/cql/thrifteries.pyc in get_response(self, cql_query, consistency_level)
             75         if self.use_cql3_methods:
             76             doquery = self._connection.client.execute_cql3_query
        ---> 77             return self.handle_cql_execution_errors(doquery, compressed_q, compress, cl)
             78         else:
             79             doquery = self._connection.client.execute_cql_query

        /home/salvus/salvus/salvus/data/local/lib/python2.7/site-packages/cql/thrifteries.pyc in handle_cql_execution_errors(self, executor, *args, **kwargs)
            103                                        "more nodes were unavailable.")
            104         except TimedOutException:
        --> 105             raise cql.OperationalError("Request did not complete within rpc_timeout.")
            106         except TApplicationException, tapp:
            107             raise cql.InternalError("Internal application error")

        OperationalError: Request did not complete within rpc_timeout.

  - [x] storage_server: make it so every database operation gets retried until success

 - [x] code to ensure storage server is started (as salvus!) when machine boots up (in `first_boot`*.py): written, now testing

  - [x] for each project:
          - find last modification time and most recent successful migrate_delete time (if any); if migrade_delete > mod time, done.
          - get current location or newest replica location from database
          - run migrate_delete there
        Locations -- right now:
            debug: got 38062 projects
            debug: of these, 22673 are on 'undefined'


 - [x] start a new node with dev hub content, which the other haproxies don't send traffic to:
         10.1.15.5

 - [x] FIRE: can't boot up vm's on 10.1.2.1!

This was missing:

        echo never > /sys/kernel/mm/transparent_hugepage/enabled; echo never > /sys/kernel/mm/transparent_hugepage/defrag
        cat /sys/kernel/mm/transparent_hugepage/enabled /sys/kernel/mm/transparent_hugepage/defrag

     - info about location/storage of a project in the the storage database:
         - cache/use *state* on each node:
            - streams:
                 - last sync time or nothing there
            - image fs:
                 - last recv time or not received
            - sparse image pool:
                 - whether or not mounted
                 - last activity  (modification time of file)
                 - last scrub time
  - [x] storage -- refactored code to have some clean well-named operations, and also store their last usage in the database
  - [x]  use a uuid to refer to storage hosts, instead of an ip address
        - this would make it possible to change the ip address of a compute machine.
        - this is what cassandra does.
        - where would uuid be stored?
        -
 - [x] disk space on cloud7 is getting problematic... 70G in "storage" so can reset that tomorrow morning.

- [x] rewrite send_streams in smc_storage:  need to locate the newest snapshot that we have
      such that there is also a stream that ends there, which isn't too small.
      Then make snapshot that starts from that point.

