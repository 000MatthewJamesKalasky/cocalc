#!/usr/bin/env python

import json, os, uuid

branches = [x.split()[-1] for x in os.popen("git branch").read().splitlines()]

logs = {}
files = {}

def set_file(obj, components, commit):
    if len(components) == 1:
        c = components[0]
        if c not in obj: # only record this the *first* time we see a file
            obj[c] = commit
    else:
        if not obj.has_key(components[0]):
            obj[components[0]] = {}
        set_file(obj[components[0]], components[1:], commit) # recurse

for branch in branches:
    cmd = "git log --name-only --pretty=format:'!%H|%an <%ae>|%ad|%s|' " + branch
    field_sep = str(uuid.uuid4())
    commit_sep = str(uuid.uuid4())

    cmd = cmd.replace('|',field_sep).replace("!",commit_sep)

    log = os.popen(cmd).read()

    commits = log.split(commit_sep)
    v = []
    d = {}
    files[branch] = d
    for entry in commits:
        if len(entry.strip()) == 0: continue
        commit, author, date, message, modified_files= entry.split(field_sep)
        modified_files = [str(x).replace('\\\\"','"').replace('\\"','') for x in modified_files.splitlines() if x]
        meta = {'commit':commit, 'author':author, 'date':date, 'message':message, 'modified_files':modified_files}
        v.append(meta)
        commit_id = meta['commit']
        for filename in modified_files:
            set_file(d, filename.split('/'), commit_id)
    logs[branch] = v

print json.dumps(logs,  separators=(',',':'))
print json.dumps(files,  separators=(',',':'))
