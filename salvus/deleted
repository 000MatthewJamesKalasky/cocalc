            elif line.startswith('<'): # use hosts listed in first column of non-commented lines in the named file
                for x in open(os.path.join(os.path.split(filename)[0], line.strip(' <>'))).readlines():
                    l = x.split('#')[0].strip().split()
                    if l:
                        groups[group].append(l[0])


--------------------


class CassandraConf(object):
    def __init__(self, filename):
        self._conf = []
        for r in open(filename).readlines():
            line = r.split('#')[0].strip()  # ignore comments and leading/trailing whitespace
            if line:
                hostname, location, token = line.split()
                self._conf.append({'hostname':hostname, 'location':location, 'token':int(token)})

    def nodes(self):
        return [x['hostname'] for x in self._conf]
                

-------------


###########################################
# memcache usage
###########################################
import memcache, tornadoasyncmemcache
MEMCACHE_SERVERS = ["127.0.0.1:11211"]
cache = memcache.Client(MEMCACHE_SERVERS)

class MemCache(object):
    """
    Use memcache to implement a simple key:value store.
    
       * Keys are hashed, but verified for correctness on read; hash
         collision implies only 1 object with that hash is stored.
         
       * Setting is done asynchronously (in that data is sent async),
         but reading is done synchronously by default, though
         get_async is also supported.
    """
    def __init__(self, namespace):
        self._cache = memcache.Client(MEMCACHE_SERVERS)
        self._async_cache = tornadoasyncmemcache.ClientPool(MEMCACHE_SERVERS, maxclients=256)
        self._ram_cache = {}
        self._namespace = namespace
        
    def key(self, key):
        return self._namespace + '.' + str(hash(key))

    def get_async(self, key, callback=None):
        # async get: result=self[key], then call the callback with result or
        # call callback with None if there is no such key.
        def f(result):
            if result is not None and result[0] == key:
                callback(result[1])
            else:
                callback(None)
        self._async_cache.get(self.key(key), callback=f)

    def __getitem__(self, key):
        # sync get:  self[key]
        c = self._cache.get(self.key(key))
        if c is not None and c[0] == key:
            return c[1]
        
    def __setitem__(self, key, result):
        # async set:   self[key] = result
        key = key.strip()
        self._async_cache.set(self.key(key), (key, result), callback=lambda data:None)

stateless_execution_cache = MemCache('stateless')


