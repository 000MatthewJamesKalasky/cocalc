    #
    # TODO TODO TODO
    ###
        # TESTING: see if cql connection works.
        tm = (new Date()).getTime()
        cassandra.cql("SELECT * FROM sage_servers", [],
            (err, results) -> res.end("#{(new Date()).getTime() - tm}\n#{err} #{results}"))
    ###

    ###
    sage_conn = new sage.Connection(
        host:'localhost'
        port:10000
        recv:(mesg) -> winston.log("sage: received message #{mesg}")
        cb: ->
            sage_conn.send(message.start_session())
            sage_conn.send(message.execute_code(0,"factor(2012)"))
    )
    ###
    
                                                        

    





class TincConf(object):
    """
    Generate and store all the tinc configuration files needed by a
    node in a private temp directory, which is deleted when this instance
    goes out of scope.

    Use obj.files() to get a mapping filename:absolute_path_to_file.
    """
    def __init__(self, ip_address):
        path = tempfile.mkdtemp()
        self._path = path

        open(os.path.join(path, 'tinc-up'),'w').write("#!/bin/sh\nifconfig $INTERFACE %s netmask 255.255.0.0"%ip_address)
        open(os.path.join(path, 'tinc.conf'),'w').write("Name = %s\nConnectTo = %s"%(ip_address, HOSTNAME))
        sh['tincd', '--config', path, '-K']
        open(os.path.join(path, ip_address),'w').write(
            "Subnet = %s/32\n%s"%(ip_address,open(os.path.join(path, 'rsa_key.priv')).read().strip()))
        
        self._files = dict([(file, os.path.join(path, file)) for file in ['tinc-up', 'tinc.conf', ip_address, 'rsa_key.pub']])

    def files(self):
        return self._files
        
    def __del__(self):
        shutil.rmtree(self._path)



----------------------

            elif line.startswith('<'): # use hosts listed in first column of non-commented lines in the named file
                for x in open(os.path.join(os.path.split(filename)[0], line.strip(' <>'))).readlines():
                    l = x.split('#')[0].strip().split()
                    if l:
                        groups[group].append(l[0])


--------------------


class CassandraConf(object):
    def __init__(self, filename):
        self._conf = []
        for r in open(filename).readlines():
            line = r.split('#')[0].strip()  # ignore comments and leading/trailing whitespace
            if line:
                hostname, location, token = line.split()
                self._conf.append({'hostname':hostname, 'location':location, 'token':int(token)})

    def nodes(self):
        return [x['hostname'] for x in self._conf]
                

-------------


###########################################
# memcache usage
###########################################
import memcache, tornadoasyncmemcache
MEMCACHE_SERVERS = ["127.0.0.1:11211"]
cache = memcache.Client(MEMCACHE_SERVERS)

class MemCache(object):
    """
    Use memcache to implement a simple key:value store.
    
       * Keys are hashed, but verified for correctness on read; hash
         collision implies only 1 object with that hash is stored.
         
       * Setting is done asynchronously (in that data is sent async),
         but reading is done synchronously by default, though
         get_async is also supported.
    """
    def __init__(self, namespace):
        self._cache = memcache.Client(MEMCACHE_SERVERS)
        self._async_cache = tornadoasyncmemcache.ClientPool(MEMCACHE_SERVERS, maxclients=256)
        self._ram_cache = {}
        self._namespace = namespace
        
    def key(self, key):
        return self._namespace + '.' + str(hash(key))

    def get_async(self, key, callback=None):
        # async get: result=self[key], then call the callback with result or
        # call callback with None if there is no such key.
        def f(result):
            if result is not None and result[0] == key:
                callback(result[1])
            else:
                callback(None)
        self._async_cache.get(self.key(key), callback=f)

    def __getitem__(self, key):
        # sync get:  self[key]
        c = self._cache.get(self.key(key))
        if c is not None and c[0] == key:
            return c[1]
        
    def __setitem__(self, key, result):
        # async set:   self[key] = result
        key = key.strip()
        self._async_cache.set(self.key(key), (key, result), callback=lambda data:None)

stateless_execution_cache = MemCache('stateless')


