    if mesg.path[mesg.path.length-1] == '/'
        errmesg = message.error
            id    : mesg.id
            error : 'path must be a filename, not a directory name (it must not end in "/")'
        socket.write_mesg('json', errmesg)
        return

<    
# Choose a random unused unix UID, where unused means by definition
# that /home/UID does not exist.  We then create that directory and
# call cb with it.  There is once in a billion years possibility of a
# race condition, so we do not worry about it.  Our uid is a random
# number between 1100 and 2^32-2=4294967294.

create_user = (cb) ->
    uid = misc.randint(1100, 4294967294)
    fs.exists("/home/#{uid}", (exists) ->
        if exists
            create_user(cb)  # This recursion won't blow stack, since
                             # it is highly unlikely to ever happen.
        else
            cmd = "useradd -U -m #{project_uuid}"
    )
#            fs.mkdir(, , () ->
#                fs.chown(
#`    child_process.exec("useradd -U -m #{project_uuid}", (error, stdout, stderr) ->cb())

    
    uid = misc.randint(1100, 4294967294)
    fs.exists("/home/#{uid}", (exists) ->
        if exists
            choose_uid(cb)  # This recursion won't blow stack, since
                            # it is highly unlikely to ever happen.
        else
            cmd = "useradd -u #{uid} -g #{uid} -m -U #{project_uuid}"
            path = "/home/#{project_uuid}"
            fs.mkdir(, , () ->
                fs.chown(

--------------------------

            # buf = null
            # console_session.on('data', (data) ->
            #     if buf == null
            #         buf = data
            #     else
            #         buf = Buffer.concat([buf, data])
            #     if buf[buf.length-1].toString() = '\u0000'
            #         client.push_to_client(from_json(buf[buf.length-1].toString()))
            # inform client of successful connection

#################################################
# HTML parsing functionality -- probably move
#################################################
#
require('async')

htmlparser = require("htmlparser")

# extract plain text from a dom tree object, as produced by htmlparser.
dom_to_text = (dom, divs=false) ->
    result = ''
    for d in dom
        switch d.type
            when 'text'
                result += d.data
            when 'tag'
                switch d.name
                    when 'div'
                        divs = true
                        result += '\n'
                    when 'br'
                        if not divs
                            result += '\n'
        if d.children?
            result += dom_to_text(d.children, divs)
    return result

# create a lossy plain text representation of html
exports.html_to_text = (opts) ->
    opts = defaults opts,
        html : required
        cb   : required    # cb(error, result)

    handler = new htmlparser.DefaultHandler (error, dom) ->
        if error
            opts.cb(error)
        else
            opts.cb(false, dom_to_text(dom))

    (new htmlparser.Parser(handler)).parseComplete(opts.html)



#######################################################
# Accounts, plans, auth, account events, etc.
#######################################################

class Plans
    # EXAMPLES:
    #  c = new (require("cassandra").Cassandra)(['localhost']); plans = c.plans()
    #  d = plans.create_plan('demo')
    #  d.data = "a demo plan"
    #  d.save()
    #  d.number_of_accounts_with_this_plan(console.log)
    #  plans.newest_plan('demo', console.log)
    constructor: (@conn) ->
    create_plan: (name) ->
        p = @plan(uuid.v4())
        p.name = name
        p.save()
        @conn.cql("UPDATE newest_plans SET plan_id=? WHERE name=?", [p.plan_id, name])
        return p
    plan: (plan_id) ->
        return new Plan(@conn, plan_id)
    newest_plan: (name, cb) ->  # cb(the newest plan with given name  | undefined)
        @conn.cql("SELECT plan_id FROM newest_plans WHERE name=?", [name],
                  (e,r) => cb(if r.length>0 then @plan(r[0].get('plan_id').value)))

class Plan
    constructor: (@conn, @plan_id, @data) ->
    save: () -> @conn.cql("UPDATE plans SET name=?, data=?, time=? WHERE plan_id=?",
                          [@name, JSON.stringify(@data), @time, @plan_id],
                        (e,r) -> console.log(e); console.log(r))
                        
    number_of_accounts_with_this_plan: (cb) ->
        @conn.cql("SELECT COUNT(*) FROM accounts WHERE plan_id=?",
                  [@plan_id], (e,r) -> cb(r[0].get('count').value))

class Accounts
    constructor: (@conn) ->

class Account
    constructor: (@conn, @account_id) ->

class Auth
    constructor: (@conn, @account_id, @provider, @login_name, @info) ->
    save: () ->
        @conn.cql("UPDATE auths SET info=? WHERE account_id=? AND provider=? AND login_name=?",
                  [@info, @account_id, @provider, @login_name])


---
             (err, results) -> cb(if results.length == 1 then from_json(results[0].get('value').value)))

             (err, results) -> cb(if results.length == 1 then from_json(results[0].get('value').value)))


        q = ""
        vals = []
        for key, val of props
            q += "#{key}=?,"
            vals.push(val)
        q = q.slice(0,-1)
        vals.push(account_id)
        @conn.cql("UPDATE accounts SET #{q} WHERE account_id=?", vals, cb)

---

    #
    # TODO TODO TODO
    ###
        # TESTING: see if cql connection works.
        tm = (new Date()).getTime()
        cassandra.cql("SELECT * FROM sage_servers", [],
            (err, results) -> res.end("#{(new Date()).getTime() - tm}\n#{err} #{results}"))
    ###

    ###
    sage_conn = new sage.Connection(
        host:'localhost'
        port:10000
        recv:(mesg) -> winston.log("sage: received message #{mesg}")
        cb: ->
            sage_conn.send(message.start_session())
            sage_conn.send(message.execute_code(0,"factor(2012)"))
    )
    ###
    
                                                        

    





class TincConf(object):
    """
    Generate and store all the tinc configuration files needed by a
    node in a private temp directory, which is deleted when this instance
    goes out of scope.

    Use obj.files() to get a mapping filename:absolute_path_to_file.
    """
    def __init__(self, ip_address):
        path = tempfile.mkdtemp()
        self._path = path

        open(os.path.join(path, 'tinc-up'),'w').write("#!/bin/sh\nifconfig $INTERFACE %s netmask 255.255.0.0"%ip_address)
        open(os.path.join(path, 'tinc.conf'),'w').write("Name = %s\nConnectTo = %s"%(ip_address, HOSTNAME))
        sh['tincd', '--config', path, '-K']
        open(os.path.join(path, ip_address),'w').write(
            "Subnet = %s/32\n%s"%(ip_address,open(os.path.join(path, 'rsa_key.priv')).read().strip()))
        
        self._files = dict([(file, os.path.join(path, file)) for file in ['tinc-up', 'tinc.conf', ip_address, 'rsa_key.pub']])

    def files(self):
        return self._files
        
    def __del__(self):
        shutil.rmtree(self._path)



----------------------

            elif line.startswith('<'): # use hosts listed in first column of non-commented lines in the named file
                for x in open(os.path.join(os.path.split(filename)[0], line.strip(' <>'))).readlines():
                    l = x.split('#')[0].strip().split()
                    if l:
                        groups[group].append(l[0])


--------------------


class CassandraConf(object):
    def __init__(self, filename):
        self._conf = []
        for r in open(filename).readlines():
            line = r.split('#')[0].strip()  # ignore comments and leading/trailing whitespace
            if line:
                hostname, location, token = line.split()
                self._conf.append({'hostname':hostname, 'location':location, 'token':int(token)})

    def nodes(self):
        return [x['hostname'] for x in self._conf]
                

-------------


###########################################
# memcache usage
###########################################
import memcache, tornadoasyncmemcache
MEMCACHE_SERVERS = ["127.0.0.1:11211"]
cache = memcache.Client(MEMCACHE_SERVERS)

class MemCache(object):
    """
    Use memcache to implement a simple key:value store.
    
       * Keys are hashed, but verified for correctness on read; hash
         collision implies only 1 object with that hash is stored.
         
       * Setting is done asynchronously (in that data is sent async),
         but reading is done synchronously by default, though
         get_async is also supported.
    """
    def __init__(self, namespace):
        self._cache = memcache.Client(MEMCACHE_SERVERS)
        self._async_cache = tornadoasyncmemcache.ClientPool(MEMCACHE_SERVERS, maxclients=256)
        self._ram_cache = {}
        self._namespace = namespace
        
    def key(self, key):
        return self._namespace + '.' + str(hash(key))

    def get_async(self, key, callback=None):
        # async get: result=self[key], then call the callback with result or
        # call callback with None if there is no such key.
        def f(result):
            if result is not None and result[0] == key:
                callback(result[1])
            else:
                callback(None)
        self._async_cache.get(self.key(key), callback=f)

    def __getitem__(self, key):
        # sync get:  self[key]
        c = self._cache.get(self.key(key))
        if c is not None and c[0] == key:
            return c[1]
        
    def __setitem__(self, key, result):
        # async set:   self[key] = result
        key = key.strip()
        self._async_cache.set(self.key(key), (key, result), callback=lambda data:None)

stateless_execution_cache = MemCache('stateless')



#######################################################################
# the below is subject to change a lot and none is implemented.

# client --> hub
# All files are added, directory is commited, new bundle is created, bundle is saved to database.
message
    event      : 'save_project'
    id         : required
    session_id : required

# hub --> client
message
    event      : 'project_saved'
    id         : required
    session_id : required


# client --> hub
message
    event      : 'create_sage_session'
    id         : required
    project_id : required

# hub --> client
message
    event      : 'sage_session_created'
    id         : required
    project_id : required
    session_id : required

# client --> hub --> sage_session
message
    event      : 'message_sage_session'  # send message to a Sage session
    id         : required
    session_id : required
    message    : required                # the message for the Sage session



# client --> hub
message
    event      : 'get_directory_tree'
    id         : required
    project_id : required

# hub --> client
message
    event      : 'directory_tree'
    id         : required
    project_id : required
    tree       : required  # object that gives the directory tree of files in this project

# client --> hub
message
    event      : 'git_command'
    id         : required
    project_id : required
    command    : required

    
    
    
    
    

#################################################
# HTML parsing functionality -- probably move
#################################################

htmlparser = require("htmlparser")

# extract plain text from a dom tree object, as produced by htmlparser.
dom_to_text = (dom, divs=false) ->
    result = ''
    for d in dom
        switch d.type
            when 'text'
                result += d.data
            when 'tag'
                switch d.name
                    when 'div'
                        divs = true
                        result += '\n'
                    when 'br'
                        if not divs
                            result += '\n'
        if d.children?
            result += dom_to_text(d.children, divs)
    return result

# create a lossy plain text representation of html
exports.html_to_text = (opts) ->
    opts = defaults opts,
        html : required
        cb   : required    # cb(error, result)

    handler = new htmlparser.DefaultHandler (error, dom) ->
        if error
            opts.cb(error)
        else
            opts.cb(false, dom_to_text(dom))

    (new htmlparser.Parser(handler)).parseComplete(opts.html)

