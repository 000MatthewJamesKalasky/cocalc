Sage Workspace
--------------

AUTHORS: 

   - William Stein

COPYRIGHT: Modified BSD






Components
----------

- Sage Session Server: serves a compute session that pushes results.

  API: 

   - new_session(push) --> id

   - execute(id, code) --> exec_id
   - interrupt(id)
   - status(id)

   - put(id, path, content):  creates file
   - get(id, path)     --> file
   - delete(id, path) 
   - files(id)         --> list of filenames
   
- simple.py -- a reference implementation of the above API.       

NEXT PLAN: Implement scalable http-based version of the above API. 

Components:

  - frontend_XXX.py -- A scalable web server that provides each of the
    above functions.  Scalable in the sense that it will of necessity
    queue up computations in a SQLAlchemy-based database and use
    memcache.

    [ hundreds of requests per second ]
    [     from appengine (say)        ]

                /|\
                 |
                 | http
                 |
                \|/

            [frontend]    (one frontend for each compute machine)

               /|||\
                |||
                |||    zeromq?
                |||
               \|||/

    [ 10-100s of Python processes (as different uid than frontend) ]
    [     running on same machine ]

 [ ] define simplest possible message protocol between frontend and
     python process and implement message protocol between frontend
     and python process

Approach 1: zeromq

     Using zeromq's REQ/REP pattern we do the following:

       * Start a Python session as a separate process and parameters:
              python session_zmq_url.py port url done_url
          port = ZMQ port to bind to as a REP socket
          url = URL to post results to (e.g., appengine)

       * The session_zmq_url process does the following in a loop:
             - using zmq, read block of code to execute, and send ack (ignored).
             - execute, sending output text (and list of created files) to url
             - when execution finishes, send zmq message saying "done" *and* GET's a certain url
      
       * When frontend receives code exec request:
             - checks for "done" zmq message from session
	     - if done, sends new code directly to session via zmq
             - if not, puts code in database for later.
             - when session calls frontend done url, it sends next
               block of code that is ready for evaluation to session,
               if there is any.

-- experiments show that something using zmq can work.  However, I'm
   not convinced it is the best approach.  Let's try a demo with a
   pure service-based HTTP approach. So...

Approach 2: HTTP-based approach

1. Start an HTTP session service

    python http_session.py WORK_URL OUTPUT_URL

      WORK_URL = url to get more work
      OUTPUT_URL = url to send output to
     
This will itself be an http server.  To get it to do work, one does a
POST request to the / path.  It immediately returns from the POST
request some "ok" response.  Then it stops being an http server and
starts exec'ing a block of code.  As output is produced, it is sent to
the OUTPUT_URL via POST's (using urllib2).  Once the code is done
being evaluated, it GET's the WORK_URL, which establishes that it is
done. The result of the GET to the WORK_URL may be another block of
code to execute, in which case the code execution starts again.  Or
the result may be a message to "stand by" (etc.).  In that case, it
switches back to webserver mode, as above.

2. Start a frontend service

    python http_frontend.py 

This will be a (maybe) multithreaded (partially) scalable http
server. It does not have to scale up that much really.  It provides
the session API. When asked for a new session, it will start a
session_http.py process as in 1 above, with WORK_URL itself and
OUTPUT_URL as requested.  It deals with all file put/get/delete
itself.  When asked to execute code it:

    * checks if session is in wait state (stored in database); if so,
      POST's code to the / URL of session
    * if session is running, it saves code to a database
    * when WORK_URL is hit, it checks database for code that needs to
      be executed; if there is any, it returns that.  If not, it sets
      (in database) that session is in wait state.




 [ ] write unit/doctests for messaging
 [ ] define the data model for the frontend
 [ ] write sqlalchemy code for the frontend model
 [ ] implement using flask the frontend webserver
 [ ] write unit/doctests for frontend

