Sage Workspace
--------------

AUTHORS: 

   - William Stein

COPYRIGHT: Modified BSD






Components
----------

- Sage Session Server: serves a compute session that pushes results.

  API: 

   - new_session(push) --> id

   - execute(id, code) --> exec_id
   - interrupt(id)
   - status(id)

   - put(id, path, content):  creates file
   - get(id, path)     --> file
   - delete(id, path) 
   - files(id)         --> list of filenames
   
- simple.py -- a reference implementation of the above API.       

NEXT PLAN: Implement scalable http-based version of the above API. 

Components:

  - frontend_XXX.py -- A scalable web server that provides each of the
    above functions.  Scalable in the sense that it will of necessity
    queue up computations in a SQLAlchemy-based database and use
    memcache.

    [ hundreds of requests per second ]
    [     from appengine (say)        ]

                /|\
                 |
                 | http
                 |
                \|/

            [frontend]    (one frontend for each compute machine)

               /|||\
                |||
                |||    zeromq?
                |||
               \|||/

    [ 10-100s of Python processes (as different uid than frontend) ]
    [     running on same machine ]

 [ ] define simplest possible message protocol between frontend and
     python process:

     Using zeromq's REQ/REP pattern we do the following:

       * Start a Python session as a separate process and parameters:
              python session_zmq_url.py port url done_url
          port = ZMQ port to bind to as a REP socket
          url = URL to post results to (e.g., appengine)

       * The session_zmq_url process does the following in a loop:
             - using zmq, read block of code to execute, and send ack (ignored).
             - execute, sending output text (and list of created files) to url
             - when execution finishes, send zmq message saying "done" *and* GET's a certain url
      
       * When frontend receives code exec request:
             - checks for "done" zmq message from session
	     - if done, sends new code directly to session via zmq
             - if not, puts code in database for later.
             - when session calls frontend done url, it sends next
               block of code that is ready for evaluation to session,
               if there is any.
             
 [ ] implement message protocol between frontend and python process

 [ ] write unit/doctests for messaging
 [ ] define the data model for the frontend
 [ ] write sqlalchemy code for the frontend model
 [ ] implement using flask the frontend webserver
 [ ] write unit/doctests for frontend

